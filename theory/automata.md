## Finite Automata (State Machines)

Chomsky hierarchy

Regular languages are defined by the languages
generated by the `Type 3` or the `Regular Grammars`.

Context-Free grammars `type 2`, are used for parsing programming languages. wwhich is above the `Type 3` Regualr Grammars because it was hard to parse the programming languages using `Regular Grammars`.

Regular Expression by Stephen Kleene was made popular by **Ken Thompson** by using them in
1. **pattern matching** in strings
2. **lexical analysis** (scan or token generation while parsing programming languages)

**Grammars define languages**
Languages composed of sentences and strings,
which is made of characters, or symbols, which belongs to some alphabet

### Symbols, alphabets and languages.

strings is what regular expressions actually recognize,a and strings always belongs to some alphabet.


**Alphabet:** ∑={a,b}
An Alphabet is a very basic concept in language theory. For example above alphabet is a set of two character a and b.

**So An Alphabet is a set of Characters**.

**Language** L1(∑) = {a, aa, b, ab, ba, bba, ...}
(infinite)

**Language is also a set, but already  a set of strings over a particular alphabet**

L2(∑) = {aa, bb, ab, ba} restrictions **length=2**
(finite)
So When we start defining and applying any restrictions on our languages, we produce grammar for this Language. Or a Formal grammar, to be precise.

**Formal Grammar**
G=(N,T,P,S) Tuple of four element.
N - **non Terminals (variables)**
T- **terminals**
P- **Production**
S- **starting symbol**

S -> aX
X -> b

X is a nonTerminal variable so it can be replaced with the value it holds, i.e with the Symbol b.

So Non Terminal Set of our Grammar is `{S,X}`

Set of **Terminals** contains all the actual characters which can appear in our string "as is".
In above example the terminals are the characers
"a" and "b".

The terminals in constrast with variables cannot be
replaces with anything and appear "as is".

**A Production is just a particular rule in our grammar**.

The above example has 2 rule.
S -> aX
X -> b

**Starting Symbol**
The initial variable where we start our analysis from.
In Our example the starting symbol is S.

**SO THE ONLY POSSIBLE STRING THE ABOVE GRAMMAR CAN ACCEPT IS THE STRING "ab"**

S -> aX -> ab

The Production rules in the form we have just seen
above are known as Backus-Naur form, or BNF.

**Regualr Grammars**
For RegExp.

BNF notation

`S -> aS`
`S -> bA`
`A -> ε` (represents a very small number, near zero) or empty string
`A -> cA`

**RegExp notation.**

a*bc*

S -> aS -> abA -> abcε

RegExp is an Syntatic Notation for the regular Grammars.

Only one nonterminal on RHS makes the regular grammar to not being able to generate **nested languages**.

1. At the very right side (right-linear)
2. At the very left side (left-linear)

**Non-Regualar Grammars**

Example **Balanced Parenthesis**
`((( )))`

**Regular Grammars** do not support nesting to match
balanced parenthesis it needs to track an extra state via stack.

**Context-Free G**
S -> (S) -> ((S)) -> (((S)))
S -> ε

But as we said the regular grammar may have a non-terminal only at the very end. But in above case
`S` is in the middle of the production rule, so a pure state machine will not work for this grammar and it requires an extra stack which is usally implemented by a push-down automata, or a recursive descent machine.

Some RegExp that supports the Nesting are slower